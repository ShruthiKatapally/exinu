#include <kernel.h>
#include <future.h>

syscall future_get(future *f, int *value) 
{
 
  if(f->state == FUTURE_EMPTY)
{
    switch(f->flag) 
{
      case FUTURE_EXCLUSIVE:
        //kprintf("future empty\n");
        f->state = FUTURE_WAITING;
        future_wait(f);
        *value = f->value;
        f->state = FUTURE_EMPTY;
        //kprintf("future consumed\n");
        break;

      case FUTURE_SHARED:
	  f->state = FUTURE_WAITING;
	  //kprintf("future_empty #get in shared mode \n");
	  enqueue(gettid(), f->get_queue);
          future_wait(f);
	 // future_get(f,value);
	 break;

      case FUTURE_QUEUE:
        if(isempty(f->set_queue)) {
          //if the get queue is empty, wait on this future
	  //kprintf("reached queue empty in get. q# %d\n",f->set_queue);
	  enqueue(gettid(), f->get_queue);
          future_wait(f);
	  future_get(f,value);
        }
        else {
          //else signal future and consume the value generated by it
	  //kprintf("reached queue not empty in get. q# %d\n",f->set_queue);
	  enqueue(gettid(), f->get_queue);
          future_signal(f);
	  future_wait(f);
	  future_get(f,value);
        }
        break;

      default:
<<<<<<< HEAD
        kprintf("invalid future flag\n");
=======
       //kprintf("invalid future flag\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
        return SYSERR;
        break;
    }
  } 
  else if(f->state == FUTURE_WAITING){
    switch(f->flag) {
      case FUTURE_EXCLUSIVE:
<<<<<<< HEAD
        kprintf("future waiting\n");
=======
       //kprintf("future waiting\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
        return SYSERR;
        break;

      case FUTURE_SHARED:
	   kprintf("future_waiting #get in shared mode\n");
	  enqueue(gettid(), f->get_queue);
          future_wait(f);
	 // future_get(f,value);
	 
        break;

      case FUTURE_QUEUE:
        break;

      default:
<<<<<<< HEAD
        kprintf("invalid future flag\n");
=======
       //kprintf("invalid future flag\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
        return SYSERR;
        break;
    }
  } 
  else if(f->state == FUTURE_VALID){
    switch(f->flag) {
      case FUTURE_EXCLUSIVE:
        *value = f->value;
        f->state = FUTURE_EMPTY;
<<<<<<< HEAD
        kprintf("future valid\n");
=======
       //kprintf("future valid\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
        break;

      case FUTURE_SHARED:
	*value = f->value;
        f->state = FUTURE_EMPTY;
	kprintf("future_valid #get = future consumed in shared mode \n");
        break;

      case FUTURE_QUEUE:
        *value = f->value;
        f->state = FUTURE_EMPTY;
        //kprintf("future valid\n");
        break;

      default:
<<<<<<< HEAD
        kprintf("invalid future flag\n");
=======
       //kprintf("invalid future flag\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
        return SYSERR;
        break;
    }
  }
  else {
<<<<<<< HEAD
    kprintf("invalid future state\n");
=======
   //kprintf("invalid future state\n");
>>>>>>> 09fc7425b8f941de83db609c5a7ebc2ab3166d50
    return SYSERR;
  }
  return OK;
}
